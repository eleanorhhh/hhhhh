# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F-iDqNu5icuKNfrwcm5PqqWy2ufl95S-
"""

from google.colab import drive
drive.mount('/content/drive')

import sys
sys.path.append('/content/drive/MyDrive/W6')

import sys
sys.path.append('/content/drive/MyDrive/00-ä¸Šèª²è³‡æ–™(å­¸æ ¡HD)/W6/package')

# Commented out IPython magic to ensure Python compatibility.
# æ­¥é©Ÿ 1: å®‰è£ TA-Lib ç³»çµ±ä¾è³´ (ç¢ºä¿æ‰€æœ‰ C å‡½å¼åº«å°±ä½)
!wget http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz
!tar -xzf ta-lib-0.4.0-src.tar.gz
# %cd ta-lib
!./configure --prefix=/usr
!make
!make install
# %cd ..

# æ­¥é©Ÿ 2: å®‰è£ Python ç¶å®š (ç§»é™¤ -t åƒæ•¸)
!pip install ta-lib

# æ­¥é©Ÿ 3: é‡æ–°å•Ÿå‹• Runtime (åŸ·è¡Œéšæ®µ -> é‡æ–°å•Ÿå‹•åŸ·è¡Œéšæ®µ)
# ç¢ºä¿æ–°çš„ç’°å¢ƒé…ç½®è¢«è¼‰å…¥

# æ­¥é©Ÿ 4: é‡æ–°åŸ·è¡Œæ‚¨çš„ import ç¨‹å¼ç¢¼

import numpy as np
import pandas as pd
import talib
import yfinance as yf
from datetime import datetime
import matplotlib.pyplot as plt
import statistics
from itertools import combinations
import warnings
warnings.filterwarnings('ignore') # å¿½ç•¥ yfinance çš„ FutureWarning

# =========================================================
# I. PARENT CLASS (åŒ…å«æ‰€æœ‰çµ±è¨ˆä¿®æ­£)
# =========================================================
class parentTSClass:
    def __init__(self, target_stock, start_date, end_date, stopLoss):
        self.target_stock = target_stock
        self.start_date = start_date
        self.end_date = end_date
        self.stopLoss = stopLoss

    def printEveryTradingInfor(self, tradingDetails):
        print("--- é€ç­†äº¤æ˜“ç´€éŒ„ (éƒ¨åˆ†çœç•¥) ---")
        for i in tradingDetails[:5]:
            print(" ".join(map(str, i)))
        if len(tradingDetails) > 5:
             print("...")
        print("-" * 20)

    def printStatisticTradingInfor(self, culReturn, winTime, lossTime, lastClosePrice, firstClosePrice, everyTranReturn):
        if not everyTranReturn:
            print("ç„¡æœ‰æ•ˆäº¤æ˜“ã€‚")
            return

        print("========================================================================== ")
        print(f"æœ€çµ‚æ·¨å ±é…¬ = {format(culReturn, '.2f')} | è³ºéŒ¢æ¬¡æ•¸ = {winTime} | è™§ææ¬¡æ•¸ = {lossTime}")

        if not np.isnan(firstClosePrice) and not np.isnan(lastClosePrice):
            print(f"è²·å…¥æŒæœ‰ (Buy & Hold) = {format(lastClosePrice - firstClosePrice, '.2f')}")

        if len(everyTranReturn) >= 2:
            print(f"å¹³å‡ç²åˆ© = {format(statistics.mean(everyTranReturn), '.2f')} | ç²åˆ©è®Šç•°æ•¸ = {format(statistics.variance(everyTranReturn), '.2f')}")
        else:
            print("çµ±è¨ˆåˆ†æ (è®Šç•°æ•¸/æ¨™æº–å·®) éœ€è¦è‡³å°‘å…©ç­†äº¤æ˜“æ•¸æ“šã€‚")

        print("========================================================================== ")

    def tradingStrategy(self): return 0 # åŸºé¡æ–¹æ³•

STRATEGY_NAMES = ['ROC', 'MA', 'RSI', 'MACD', 'BBANDS']

# =========================================================
# II. æ ¸å¿ƒè¨Šè™Ÿè¨ˆç®—å‡½æ•¸ (å·²å¼·åŒ–ç‚ºæœ€é­¯æ£’çš„ NumPy æ•¸çµ„æ“ä½œ)
# =========================================================
def calculate_signal_for_strategy(df, strategy_name):
    """
    ç‚ºå–®ä¸€ç­–ç•¥è¨ˆç®—æ¯æ—¥è¨Šè™Ÿ (+1: Buy, -1: Sell, 0: Hold)
    ã€å·²å¼·åŒ–ç‚ºæœ€é­¯æ£’çš„ NumPy æ•¸çµ„æ“ä½œã€‘
    """
    df = df.copy()
    close_series = df['close'].ffill()

    if len(close_series) < 30 or close_series.isnull().all():
        df['Signal'] = 0
        return df['Signal']

    close_values = close_series.values # NumPy é™£åˆ— for talib

    # åˆå§‹åŒ–è¨Šè™Ÿæ¬„ä½
    df['Signal'] = 0

    # ç­–ç•¥è¨ˆç®—å€å¡Š
    if strategy_name == 'ROC':
        ROC = talib.ROC(close_values, timeperiod=12)
        ROC = np.nan_to_num(ROC) # å°‡ NaN è½‰ç‚º 0
        df['Signal'] = np.where(ROC > 0, 1, np.where(ROC < 0, -1, 0))

    elif strategy_name == 'MA':
        MA5 = talib.SMA(close_values, timeperiod=5)
        MA20 = talib.SMA(close_values, timeperiod=20)
        MA5 = np.nan_to_num(MA5)
        MA20 = np.nan_to_num(MA20)
        df['Signal'] = np.where(MA5 > MA20, 1, np.where(MA5 < MA20, -1, 0))

    elif strategy_name == 'RSI':
        RSI = talib.RSI(close_values, timeperiod=14)
        RSI_Series = pd.Series(np.nan_to_num(RSI), index=df.index)
        buy_cond = np.array((RSI_Series.shift(1) <= 30) & (RSI_Series > 30))
        sell_cond = np.array((RSI_Series.shift(1) >= 70) & (RSI_Series < 70))
        df['Signal'] = np.where(buy_cond, 1, np.where(sell_cond, -1, 0))

    elif strategy_name == 'MACD':
        DIF, MACD, HIST = talib.MACD(close_values, fastperiod=12, slowperiod=26, signalperiod=9)
        DIF_Series = pd.Series(np.nan_to_num(DIF), index=df.index)
        MACD_Series = pd.Series(np.nan_to_num(MACD), index=df.index)

        buy_cond = np.array((DIF_Series.shift(1) <= MACD_Series.shift(1)) & (DIF_Series > MACD_Series))
        sell_cond = np.array((DIF_Series.shift(1) >= MACD_Series.shift(1)) & (DIF_Series < MACD_Series))
        df['Signal'] = np.where(buy_cond, 1, np.where(sell_cond, -1, 0))

    elif strategy_name == 'BBANDS':
        Upper, Middle, Lower = talib.BBANDS(close_values, timeperiod=20, nbdevup=2, nbdevdn=2)
        Lower_Series = pd.Series(np.nan_to_num(Lower, nan=close_values.min()), index=df.index)
        Upper_Series = pd.Series(np.nan_to_num(Upper, nan=close_values.max()), index=df.index)

        buy_cond = np.array(close_series < Lower_Series)
        sell_cond = np.array(close_series > Upper_Series)
        df['Signal'] = np.where(buy_cond, 1, np.where(sell_cond, -1, 0))

    # ã€æœ€çµ‚ç¢ºä¿ã€‘ï¼šå°‡æ‰€æœ‰å‰©é¤˜çš„ NaN å€¼è¨­ç‚º 0
    df['Signal'].fillna(0, inplace=True)
    return df['Signal']

# =========================================================
# III. æ ¸å¿ƒå›æ¸¬å‡½æ•¸ï¼šåŸ·è¡Œå¯¬é¬†å‚¾å‘è¦å‰‡ (æœ€çµ‚ä¿®æ­£)
# =========================================================
def run_backtest_combo(combo_names, symbol, start_date, end_date):

    # 1. æ•¸æ“šä¸‹è¼‰èˆ‡æº–å‚™
    df = yf.download(symbol, start_date, end_date, progress=False)

    if df.empty or len(df) < 30:
        return 0

    df.rename(columns={'Close':'close', 'High':'high', 'Low':'low', 'Open':'open', 'Volume':'volume' }, inplace = True)

    # 2. è¨ˆç®—è¨Šè™Ÿä¸¦èšåˆ
    N_combo = len(combo_names)
    signal_columns = []

    for name in combo_names:
        signal_col_name = f'{name}_Signal'
        df[signal_col_name] = calculate_signal_for_strategy(df.copy(), name)
        signal_columns.append(signal_col_name)

    df['Total_Signal'] = df[signal_columns].sum(axis=1)

    # 3. äº¤æ˜“åŸ·è¡Œ
    flag = 0  # 0: æœªæŒæœ‰, 1: æŒæœ‰
    buyPrice = 0
    tax = 0
    culReturn = 0

    # æ‰¾åˆ°ç¬¬ä¸€å€‹é NaN çš„ç´¢å¼•ä½œç‚ºå›æ¸¬èµ·é»
    start_index = df['Total_Signal'].first_valid_index()
    if start_index is None:
        return 0

    start_idx_num = df.index.get_loc(start_index)

    # ç²å– Buy & Hold åŸºæº–é»
    firstClosePrice = df.iloc[start_idx_num]['close']
    lastClosePrice = df.iloc[-1]['close']
    everyTranReturn = [] # ç”¨æ–¼çµ±è¨ˆ

    for x in range(start_idx_num, len(df)):
        current_close = df.iloc[x]['close']
        current_signal_sum = df.iloc[x]['Total_Signal']

        # A. å¯¬é¬†è²·å…¥æ¢ä»¶ (æ·¨è¨Šè™Ÿç¸½å’Œ >= 1)
        if flag == 0 and current_signal_sum >= 1:
            buyPrice = current_close
            tax = buyPrice * 0.001425
            flag = 1

        # B. å¯¬é¬†è³£å‡ºæ¢ä»¶ (æ·¨è¨Šè™Ÿç¸½å’Œ <= -1)
        elif flag == 1 and current_signal_sum <= -1:
            sellPrice = current_close
            tax += sellPrice * 0.001425 + sellPrice * 0.003
            profit = (sellPrice - buyPrice) - tax
            culReturn += profit
            everyTranReturn.append(profit)

            flag = 0
            buyPrice = 0
            tax = 0

    # çµæŸå¹³å€‰
    if flag == 1:
        sellPrice = df.iloc[-1]['close']
        tax += sellPrice * 0.001425 + sellPrice * 0.003
        profit = (sellPrice - buyPrice) - tax
        culReturn += profit
        everyTranReturn.append(profit)

    return culReturn

# =========================================================
# IV. ä¸»æœå°‹è¿´åœˆ (åŸ·è¡Œæ‰€æœ‰æ¸¬è©¦ï¼Œå«éŒ¯èª¤é˜²ç¦¦)
# =========================================================
def run_full_search():
    # 1. çµ„åˆç”Ÿæˆ
    strategy_names = STRATEGY_NAMES
    all_combos = []
    for r in range(1, 4):
        all_combos.extend(list(combinations(strategy_names, r)))

    # 2. å®šç¾©å›æ¸¬æƒ…å¢ƒ (åŒ…å«ç«¶è³½è¦æ±‚çš„ä¸‰å€‹è¶¨å‹¢)
    test_scenarios = {
        'Uptrend': {'symbol': '2330.TW', 'start': datetime(2013, 1, 1), 'end': datetime(2022, 12, 31)},
        'Sideways': {'symbol': '2412.TW', 'start': datetime(2013, 1, 1), 'end': datetime(2022, 12, 31)},
        'Downtrend': {'symbol': '2498.TW', 'start': datetime(2013, 1, 1), 'end': datetime(2022, 12, 31)}
    }

    # å°‡åˆå§‹å€¼è¨­ç‚ºç¢ºå®šçš„è² æ•¸ï¼Œé¿å…æ¥µé™æµ®é»æ•¸æ¯”è¼ƒéŒ¯èª¤
    best_results = {
        'Uptrend': {'Return': -10000.0, 'Combination': None},
        'Sideways': {'Return': -10000.0, 'Combination': None},
        'Downtrend': {'Return': -10000.0, 'Combination': None}
    }

    # 3. åŸ·è¡Œæœå°‹
    for trend, params in test_scenarios.items():
        symbol = params['symbol']
        start_date = params['start']
        end_date = params['end']

        print(f"\n--- é–‹å§‹æœå°‹: {trend} ({symbol}) --- ç¸½å…± {len(all_combos)} ç¨®çµ„åˆ")

        for combo in all_combos:
            current_return = 0

            try:
                # å‘¼å«æ ¸å¿ƒå›æ¸¬å‡½æ•¸
                current_return = run_backtest_combo(combo, symbol, start_date, end_date)

            except ValueError as e:
                # æ•ç² Pandas æ­§ç¾©éŒ¯èª¤
                if "The truth value of a Series is ambiguous" in str(e):
                    # è³¦äºˆæ¥µä½å ±é…¬ï¼Œç¢ºä¿å®ƒä¸æœƒè¢«é¸ç‚ºæœ€ä½³ï¼Œä¸¦ç¹¼çºŒåŸ·è¡Œ
                    current_return = -10000.0
                else:
                    raise e # é‡åˆ°å…¶ä»–æœªçŸ¥çš„ ValueErrorï¼Œéœ€è¦é‡æ–°æ‹‹å‡º

            if current_return > best_results[trend]['Return']:
                best_results[trend]['Return'] = current_return
                best_results[trend]['Combination'] = combo

        print(f"âœ… è©²è¶¨å‹¢æœ€ä½³çµ„åˆ ({trend}): {best_results[trend]['Combination']} | æ·¨å ±é…¬: {best_results[trend]['Return']:.2f} å…ƒ")

    print("\n==========================================================")
    print("ğŸ† ç«¶è³½çµæœå½™ç¸½ ğŸ†")
    print("==========================================================")
    for trend, result in best_results.items():
        print(f"{trend} ({test_scenarios[trend]['symbol']}):")
        print(f"  æœ€é«˜å ±é…¬: {result['Return']:.2f} å…ƒ")
        print(f"  ç­–ç•¥çµ„åˆ: {result['Combination']}")

    print("\nè«‹å°‡é€™ä¸‰å€‹è¶¨å‹¢çš„æœ€ä½³å ±é…¬å¡«å…¥ç¹³äº¤æ–‡ä»¶ã€‚")

# åŸ·è¡Œç¸½æœå°‹
run_full_search()